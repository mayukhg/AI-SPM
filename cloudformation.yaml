AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Enhanced CloudFormation template to deploy the AI Security Posture Management (AI-SPM) Platform
  with advanced security features including OAuth 2.0/SAML authentication, real-time security monitoring
  with SIEM integration, AI/ML security controls, and automated privacy governance. This template 
  provisions a comprehensive security infrastructure with VPC, encrypted RDS database, ECS Fargate 
  services for enhanced Node.js API Gateway and specialized Python microservices, S3 bucket with 
  security controls, CloudFront distribution, and integrated security services like CloudTrail, 
  GuardDuty, and Security Hub. The infrastructure supports Istio service mesh deployment with 
  zero-trust architecture, automatic mTLS, and comprehensive observability.

Parameters:
  DBPassword:
    Type: String
    Description: Password for the RDS PostgreSQL database. Must be at least 8 characters.
    MinLength: 8
    NoEcho: true

  WizClientId:
    Type: String
    Description: (Optional) Wiz Client ID for Wiz integration.
    Default: ""

  WizClientSecret:
    Type: String
    Description: (Optional) Wiz Client Secret for Wiz integration.
    Default: ""
    NoEcho: true

  NodeJSImageTag:
    Type: String
    Description: Docker image tag for the Node.js API Gateway (e.g., 'latest' or a specific version from ECR).
    Default: "latest"

  PythonImageTag:
    Type: String
    Description: Docker image tag for Python microservices (e.g., 'latest' or a specific version from ECR).
    Default: "latest"

  APIGatewayDesiredCount:
    Type: Number
    Description: Desired number of tasks for the Node.js API Gateway service.
    Default: 2
    MinValue: 1

  MicroservicesDesiredCount:
    Type: Number
    Description: Desired number of tasks for each Python microservice.
    Default: 1
    MinValue: 1

  EnableMicroservices:
    Type: String
    Description: Whether to deploy Python microservices (true/false). Set to false for API Gateway only deployment.
    Default: "true"
    AllowedValues: ["true", "false"]

  ServiceMeshReady:
    Type: String
    Description: Whether to configure infrastructure for service mesh deployment (true/false).
    Default: "true"
    AllowedValues: ["true", "false"]

  KubernetesClusterName:
    Type: String
    Description: (Optional) Name of existing EKS cluster for service mesh deployment.
    Default: ""

  SSLCertificateArn:
    Type: String
    Description: (Optional) ARN of the SSL certificate for CloudFront and ALB. If not provided, HTTP will be used (not recommended for production).
    Default: ""

Conditions:
  CreateWizClientIdSecret: !Not [!Equals [!Ref WizClientId, ""]]
  CreateWizClientSecretSecret: !Not [!Equals [!Ref WizClientSecret, ""]]
  HasSSLCertificate: !Not [!Equals [!Ref SSLCertificateArn, ""]]
  DeployMicroservices: !Equals [!Ref EnableMicroservices, "true"]
  EnableServiceMesh: !Equals [!Ref ServiceMeshReady, "true"]
  HasExistingCluster: !Not [!Equals [!Ref KubernetesClusterName, ""]]

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-VPC

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-IGW

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  # Subnets - Two public and two private for high availability
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicSubnet1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicSubnet2

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.3.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PrivateSubnet1

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.4.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PrivateSubnet2

  # NAT Gateways for private subnets
  EIP1:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  EIP2:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  NatGateway1:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt EIP1.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-NatGateway1

  NatGateway2:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt EIP2.AllocationId
      SubnetId: !Ref PublicSubnet2
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-NatGateway2

  # Route Tables
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PublicRouteTable

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  AssociatePublicSubnet1RouteTable:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  AssociatePublicSubnet2RouteTable:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  PrivateRouteTable1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PrivateRouteTable1

  PrivateRoute1:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway1

  AssociatePrivateSubnet1RouteTable:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable1

  PrivateRouteTable2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-PrivateRouteTable2

  PrivateRoute2:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable2
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway2

  AssociatePrivateSubnet2RouteTable:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable2

  # IAM Roles and Policies
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-ECSTaskExecutionRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  AppServerRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-AppServerRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com # For ECS Tasks
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-AppServerSecretsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                # Restrict to specific secrets if ARNs are known/created by this template,
                # or use a broader permission with conditions based on secret name patterns.
                # For now, allowing access to secrets tagged by this stack or named with stack prefix.
                Resource: !Sub arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${AWS::StackName}*
              # Add other permissions if the app needs to interact with other AWS services
              # - Effect: Allow
              #   Action:
              #     - s3:GetObject
              #   Resource: !Sub arn:aws:s3:::your-app-specific-bucket/*

  # Instance profile for EC2 (if used in the future, not for current Fargate setup)
  AppServerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub ${AWS::StackName}-AppServerInstanceProfile
      Roles:
        - !Ref AppServerRole

  # Secrets Manager
  DBPasswordSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub ${AWS::StackName}/DBPassword
      Description: "Database password for the AI-SPM application RDS instance"
      SecretString: !Ref DBPassword
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DBPassword

  SessionSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub ${AWS::StackName}/SESSION_SECRET
      Description: "Session secret for the AI-SPM application"
      GenerateSecretString:
        SecretStringTemplate: '{}'
        GenerateStringKey: 'sessionkey'
        PasswordLength: 32
        ExcludeCharacters: '"@/\'
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-SessionSecret

  WizClientIdSecret:
    Type: AWS::SecretsManager::Secret
    Condition: CreateWizClientIdSecret
    Properties:
      Name: !Sub ${AWS::StackName}/WIZ_CLIENT_ID
      Description: "Wiz Client ID for AI-SPM integration"
      SecretString: !Ref WizClientId
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-WizClientId

  WizClientSecretSecret:
    Type: AWS::SecretsManager::Secret
    Condition: CreateWizClientSecretSecret
    Properties:
      Name: !Sub ${AWS::StackName}/WIZ_CLIENT_SECRET
      Description: "Wiz Client Secret for AI-SPM integration"
      SecretString: !Ref WizClientSecret
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-WizClientSecret

  # RDS PostgreSQL Database
  AppServerSecurityGroup: # Defined first as RDSSecurityGroup refers to it
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${AWS::StackName}-AppServerSecurityGroup
      GroupDescription: "Security group for the API Gateway (ECS Tasks/ALB)"
      VpcId: !Ref VPC
      # Ingress rules will be added for ALB (HTTP/HTTPS)
      # Egress to RDS will be implicitly allowed by RDS SG Ingress from this SG.
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-AppServerSG

  MicroservicesSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: DeployMicroservices
    Properties:
      GroupName: !Sub ${AWS::StackName}-MicroservicesSecurityGroup
      GroupDescription: "Security group for Python Microservices"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8001
          ToPort: 8004
          SourceSecurityGroupId: !Ref AppServerSecurityGroup
          Description: "Allow traffic from API Gateway to microservices"
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-MicroservicesSG

  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: "Subnet group for AI-SPM RDS instance"
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DBSubnetGroup

  RDSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${AWS::StackName}-RDSSecurityGroup
      GroupDescription: "Allow DB connections from AppServer"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref AppServerSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-RDSSG

  RDSPostgresInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub ${AWS::StackName}-db-instance
      AllocatedStorage: "20" # Minimum 20 GiB
      DBInstanceClass: db.t3.micro # Choose an appropriate instance class
      Engine: postgres
      EngineVersion: "14" # Specify your desired PostgreSQL version
      MasterUsername: ai_spm_user
      MasterUserPassword: !Ref DBPassword # Directly using the parameter for initial creation
      DBName: ai_spm_db
      DBSubnetGroupName: !Ref DBSubnetGroup
      VPCSecurityGroups:
        - !Ref RDSSecurityGroup
      PubliclyAccessible: false
      StorageType: gp2
      BackupRetentionPeriod: 7 # Days
      DeleteAutomatedBackups: true # Set to false for production if you want to keep backups after deletion
      DeletionPolicy: Snapshot # Or 'Delete' for non-prod. 'Snapshot' requires a final snapshot name.
      # FinalDBSnapshotIdentifier: !Sub ${AWS::StackName}-final-snapshot-${AWS::Region} # Required if DeletionPolicy is Snapshot
      CopyTagsToSnapshot: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-RDSInstance

  # ECR Repository for Node.js API Gateway
  ECRRepositoryNodeJS:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub ${AWS::StackName}/nodejs-api-gateway
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ECRRepository-NodeJS

  # ECR Repository for Python Microservices
  ECRRepositoryPython:
    Type: AWS::ECR::Repository
    Condition: DeployMicroservices
    Properties:
      RepositoryName: !Sub ${AWS::StackName}/python-microservices
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ECRRepository-Python

  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub ${AWS::StackName}-Cluster
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ECSCluster

  # ECS Task Definition for Node.js API Gateway
  APIGatewayTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub ${AWS::StackName}-APIGateway
      Cpu: "512"  # 0.5 vCPU
      Memory: "1024" # 1 GB RAM
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref ECSTaskExecutionRole
      TaskRoleArn: !Ref AppServerRole
      ContainerDefinitions:
        - Name: !Sub ${AWS::StackName}-APIGateway
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryNodeJS}:${NodeJSImageTag}"
          PortMappings:
            - ContainerPort: 5000
              Protocol: tcp
          Environment:
            - Name: NODE_ENV
              Value: production
            - Name: PORT
              Value: "5000"
            - Name: PGHOST
              Value: !GetAtt RDSPostgresInstance.Endpoint.Address
            - Name: PGPORT
              Value: !GetAtt RDSPostgresInstance.Endpoint.Port
            - Name: PGUSER
              Value: ai_spm_user
            - Name: PGDATABASE
              Value: ai_spm_db
            - Name: WIZ_CLIENT_ID
              Value: !If [CreateWizClientIdSecret, !Ref WizClientId, ""]
            - Name: WIZ_CLIENT_SECRET
              Value: !If [CreateWizClientSecretSecret, !Ref WizClientSecret, ""]
            - Name: AI_SCANNER_URL
              Value: !If [DeployMicroservices, !Sub "http://${AIServiceDiscovery}.${AWS::StackName}-microservices.local:8001", ""]
            - Name: DATA_INTEGRITY_URL
              Value: !If [DeployMicroservices, !Sub "http://${DataIntegrityServiceDiscovery}.${AWS::StackName}-microservices.local:8002", ""]
            - Name: WIZ_INTEGRATION_URL
              Value: !If [DeployMicroservices, !Sub "http://${WizIntegrationServiceDiscovery}.${AWS::StackName}-microservices.local:8003", ""]
            - Name: COMPLIANCE_ENGINE_URL
              Value: !If [DeployMicroservices, !Sub "http://${ComplianceEngineServiceDiscovery}.${AWS::StackName}-microservices.local:8004", ""]
          Secrets:
            - Name: PGPASSWORD
              ValueFrom: !Ref DBPasswordSecret
            - Name: SESSION_SECRET
              ValueFrom: !Ref SessionSecret
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref APIGatewayLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: api-gateway
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-APIGatewayTaskDefinition

  # ECS Task Definition for Python Microservices
  MicroservicesTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Condition: DeployMicroservices
    Properties:
      Family: !Sub ${AWS::StackName}-Microservices
      Cpu: "1024"  # 1 vCPU
      Memory: "2048" # 2 GB RAM
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !Ref ECSTaskExecutionRole
      TaskRoleArn: !Ref AppServerRole
      ContainerDefinitions:
        - Name: ai-scanner
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryPython}:ai-scanner-${PythonImageTag}"
          PortMappings:
            - ContainerPort: 8001
              Protocol: tcp
          Environment:
            - Name: ENVIRONMENT
              Value: production
            - Name: PGHOST
              Value: !GetAtt RDSPostgresInstance.Endpoint.Address
            - Name: PGPORT
              Value: !GetAtt RDSPostgresInstance.Endpoint.Port
            - Name: PGUSER
              Value: ai_spm_user
            - Name: PGDATABASE
              Value: ai_spm_db
          Secrets:
            - Name: PGPASSWORD
              ValueFrom: !Ref DBPasswordSecret
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref MicroservicesLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ai-scanner
        - Name: data-integrity
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryPython}:data-integrity-${PythonImageTag}"
          PortMappings:
            - ContainerPort: 8002
              Protocol: tcp
          Environment:
            - Name: ENVIRONMENT
              Value: production
            - Name: PGHOST
              Value: !GetAtt RDSPostgresInstance.Endpoint.Address
            - Name: PGPORT
              Value: !GetAtt RDSPostgresInstance.Endpoint.Port
            - Name: PGUSER
              Value: ai_spm_user
            - Name: PGDATABASE
              Value: ai_spm_db
          Secrets:
            - Name: PGPASSWORD
              ValueFrom: !Ref DBPasswordSecret
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref MicroservicesLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: data-integrity
        - Name: wiz-integration
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryPython}:wiz-integration-${PythonImageTag}"
          PortMappings:
            - ContainerPort: 8003
              Protocol: tcp
          Environment:
            - Name: ENVIRONMENT
              Value: production
            - Name: PGHOST
              Value: !GetAtt RDSPostgresInstance.Endpoint.Address
            - Name: PGPORT
              Value: !GetAtt RDSPostgresInstance.Endpoint.Port
            - Name: PGUSER
              Value: ai_spm_user
            - Name: PGDATABASE
              Value: ai_spm_db
            - Name: WIZ_CLIENT_ID
              Value: !If [CreateWizClientIdSecret, !Ref WizClientId, ""]
            - Name: WIZ_CLIENT_SECRET
              Value: !If [CreateWizClientSecretSecret, !Ref WizClientSecret, ""]
          Secrets:
            - Name: PGPASSWORD
              ValueFrom: !Ref DBPasswordSecret
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref MicroservicesLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: wiz-integration
        - Name: compliance-engine
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryPython}:compliance-engine-${PythonImageTag}"
          PortMappings:
            - ContainerPort: 8004
              Protocol: tcp
          Environment:
            - Name: ENVIRONMENT
              Value: production
            - Name: PGHOST
              Value: !GetAtt RDSPostgresInstance.Endpoint.Address
            - Name: PGPORT
              Value: !GetAtt RDSPostgresInstance.Endpoint.Port
            - Name: PGUSER
              Value: ai_spm_user
            - Name: PGDATABASE
              Value: ai_spm_db
          Secrets:
            - Name: PGPASSWORD
              ValueFrom: !Ref DBPasswordSecret
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref MicroservicesLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: compliance-engine
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-MicroservicesTaskDefinition

  # Log Group for API Gateway
  APIGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /ecs/${AWS::StackName}/api-gateway
      RetentionInDays: 14
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-APIGatewayLogGroup

  # Log Group for Python Microservices
  MicroservicesLogGroup:
    Type: AWS::Logs::LogGroup
    Condition: DeployMicroservices
    Properties:
      LogGroupName: !Sub /ecs/${AWS::StackName}/microservices
      RetentionInDays: 14
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-MicroservicesLogGroup

  # ECS Service for API Gateway
  APIGatewayService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: !Sub ${AWS::StackName}-APIGateway
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref APIGatewayTaskDefinition
      DesiredCount: !Ref APIGatewayDesiredCount
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          Subnets:
            - !Ref PrivateSubnet1
            - !Ref PrivateSubnet2
          SecurityGroups:
            - !Ref AppServerSecurityGroup
          AssignPublicIp: DISABLED
      LoadBalancers:
        - TargetGroupArn: !Ref ALBTargetGroup
          ContainerName: !Sub ${AWS::StackName}-APIGateway
          ContainerPort: 5000
      HealthCheckGracePeriodSeconds: 60
      DeploymentConfiguration:
        MinimumHealthyPercent: 50
        MaximumPercent: 200
      ServiceRegistries:
        - RegistryArn: !GetAtt APIGatewayServiceDiscovery.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-APIGatewayService
    DependsOn:
      - ALBTargetGroup

  # ECS Service for Python Microservices
  MicroservicesService:
    Type: AWS::ECS::Service
    Condition: DeployMicroservices
    Properties:
      ServiceName: !Sub ${AWS::StackName}-Microservices
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref MicroservicesTaskDefinition
      DesiredCount: !Ref MicroservicesDesiredCount
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          Subnets:
            - !Ref PrivateSubnet1
            - !Ref PrivateSubnet2
          SecurityGroups:
            - !Ref MicroservicesSecurityGroup
          AssignPublicIp: DISABLED
      HealthCheckGracePeriodSeconds: 120
      DeploymentConfiguration:
        MinimumHealthyPercent: 50
        MaximumPercent: 200
      ServiceRegistries:
        - RegistryArn: !GetAtt AIServiceDiscovery.Arn
        - RegistryArn: !GetAtt DataIntegrityServiceDiscovery.Arn
        - RegistryArn: !GetAtt WizIntegrationServiceDiscovery.Arn
        - RegistryArn: !GetAtt ComplianceEngineServiceDiscovery.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-MicroservicesService

  # Service Discovery Namespace for Microservices
  ServiceDiscoveryNamespace:
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Condition: DeployMicroservices
    Properties:
      Name: !Sub ${AWS::StackName}-microservices.local
      Vpc: !Ref VPC
      Description: Service discovery namespace for AI-SPM microservices

  # Service Discovery Services
  APIGatewayServiceDiscovery:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: api-gateway
      NamespaceId: !If [DeployMicroservices, !Ref ServiceDiscoveryNamespace, !Ref "AWS::NoValue"]
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 10
        NamespaceId: !If [DeployMicroservices, !Ref ServiceDiscoveryNamespace, !Ref "AWS::NoValue"]
      HealthCheckCustomConfig:
        FailureThreshold: 1

  AIServiceDiscovery:
    Type: AWS::ServiceDiscovery::Service
    Condition: DeployMicroservices
    Properties:
      Name: ai-scanner
      NamespaceId: !Ref ServiceDiscoveryNamespace
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 10
        NamespaceId: !Ref ServiceDiscoveryNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1

  DataIntegrityServiceDiscovery:
    Type: AWS::ServiceDiscovery::Service
    Condition: DeployMicroservices
    Properties:
      Name: data-integrity
      NamespaceId: !Ref ServiceDiscoveryNamespace
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 10
        NamespaceId: !Ref ServiceDiscoveryNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1

  WizIntegrationServiceDiscovery:
    Type: AWS::ServiceDiscovery::Service
    Condition: DeployMicroservices
    Properties:
      Name: wiz-integration
      NamespaceId: !Ref ServiceDiscoveryNamespace
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 10
        NamespaceId: !Ref ServiceDiscoveryNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1

  ComplianceEngineServiceDiscovery:
    Type: AWS::ServiceDiscovery::Service
    Condition: DeployMicroservices
    Properties:
      Name: compliance-engine
      NamespaceId: !Ref ServiceDiscoveryNamespace
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 10
        NamespaceId: !Ref ServiceDiscoveryNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1

  # S3 Bucket for Frontend Static Assets
  S3FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ${AWS::StackName}-frontend-assets-${AWS::AccountId}-${AWS::Region} # Globally unique bucket name
      AccessControl: Private # Recommended: Use OAC with CloudFront instead of public bucket
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true
      WebsiteConfiguration: # Optional if only accessed via CloudFront OAC
        IndexDocument: index.html
        ErrorDocument: index.html # For SPAs, redirect errors to index.html
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-FrontendS3Bucket
    # DeletionPolicy: Retain # Recommended for production buckets
    # UpdateReplacePolicy: Retain

  # S3BucketPolicy: # We will use Origin Access Control (OAC) with CloudFront, so a public bucket policy is not preferred.
  #   Type: AWS::S3::BucketPolicy
  #   Properties:
  #     Bucket: !Ref S3FrontendBucket
  #     PolicyDocument:
  #       Statement:
  #         - Sid: PublicReadGetObjectForCloudFront
  #           Effect: Allow
  #           Principal:
  #             AWS: !Sub arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity EEXAMPLE # Replace with OAI if used
  #           Action: s3:GetObject
  #           Resource: !Sub arn:aws:s3:::${S3FrontendBucket}/*

  # CloudFront Distribution
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub ${AWS::StackName}-S3-OAC
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Comment: !Sub Distribution for ${AWS::StackName}
        Enabled: true
        HttpVersion: http2
        IPV6Enabled: true
        DefaultRootObject: index.html
        Origins:
          - Id: !Sub S3-${S3FrontendBucket} # S3 Origin
            DomainName: !GetAtt S3FrontendBucket.RegionalDomainName # Use regional domain name for S3
            S3OriginConfig:
              OriginAccessIdentity: "" # Required to be empty string when using OAC
            OriginAccessControlId: !Ref CloudFrontOriginAccessControl
          # ALB Origin for API will be added later if we create a combined distribution.
          # For now, focusing on S3 frontend.
          # - Id: !Sub ALB-${AWS::StackName}
          #   DomainName: !GetAtt ApplicationLoadBalancer.DNSName # ALB DNS
          #   CustomOriginConfig:
          #     HTTPPort: 80
          #     HTTPSPort: 443
          #     OriginProtocolPolicy: http-only # or https-only if ALB listener is HTTPS
        DefaultCacheBehavior:
          TargetOriginId: !Sub S3-${S3FrontendBucket}
          ViewerProtocolPolicy: redirect-to-https # Recommended
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          DefaultTTL: 86400 # 1 day
          MaxTTL: 31536000 # 1 year
          MinTTL: 0
        # Add CacheBehavior for API path /api/* to route to ALB later if needed
        # - PathPattern: /api/*
        #   TargetOriginId: !Sub ALB-${AWS::StackName} # ALB Origin ID
        #   ViewerProtocolPolicy: redirect-to-https
        #   AllowedMethods: ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT']
        #   CachedMethods: ['HEAD', 'OPTIONS'] # Cache OPTIONS for preflight
        #   Compress: true
        #   ForwardedValues:
        #     QueryString: true
        #     Headers: # Forward necessary headers for API
        #       - Authorization
        #       - Content-Type
        #     Cookies:
        #       Forward: all
        #   DefaultTTL: 0
        #   MaxTTL: 0
        #   MinTTL: 0
        ViewerCertificate: !If
          - HasSSLCertificate
          - ViewerCertificate:
              AcmCertificateArn: !Ref SSLCertificateArn
              SslSupportMethod: sni-only
              MinimumProtocolVersion: TLSv1.2_2021
          - ViewerCertificate: # Default to CloudFront owned certificate
              CloudFrontDefaultCertificate: true
        # Logging: # Optional: Configure access logging
        #   Bucket: your-logging-bucket.s3.amazonaws.com
        #   Prefix: !Sub ${AWS::StackName}/cloudfront-logs/
        #   IncludeCookies: false
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-CloudFrontDistribution

  S3BucketPolicyForCloudFrontOAC:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref S3FrontendBucket
      PolicyDocument:
        Version: "2012-10-17" # AWS recommends using "2012-10-17" or newer
        Statement:
          - Sid: AllowCloudFrontServicePrincipalReadOnly
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${S3FrontendBucket}/*
            Condition:
              StringEquals:
                "AWS:SourceArn": !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}

  # Application Load Balancer
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${AWS::StackName}-ALBSecurityGroup
      GroupDescription: "Allow HTTP/HTTPS to ALB"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ALBSG

  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${AWS::StackName}-ALB
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '60'
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ALB

  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${AWS::StackName}-AppTargetGroup
      VpcId: !Ref VPC
      Protocol: HTTP
      Port: 5000 # Port the ECS tasks are listening on
      HealthCheckPath: /api/health # Placeholder - ensure your app has a health check endpoint
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Matcher:
        HttpCode: 200-299
      TargetType: ip # For Fargate
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-ALBTG
    DependsOn: # Ensure AppServerSecurityGroup is created before target group tries to use it implicitly for health checks
      - AppServerSecurityGroup

  # Listener for HTTP (redirects to HTTPS if SSL cert is provided)
  ALBListenerHTTP:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - !If # If SSL cert exists, redirect HTTP to HTTPS, else forward to ECS for API (or fixed response if no API default)
          - HasSSLCertificate
          - Type: redirect
            RedirectConfig:
              Protocol: HTTPS
              Port: "443"
              StatusCode: HTTP_301
          - Type: forward # If no SSL, forward /api/* to ECS, default might be fixed response
            TargetGroupArn: !Ref ALBTargetGroup # This default action might need adjustment based on actual domain strategy
            # Or, for a scenario where CloudFront is the entry point, this listener might only have specific rules
            # and no general default forward to ECS.
            # Let's assume for now API is the primary purpose of ALB.

  # Listener for HTTPS (conditional)
  ALBListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Condition: HasSSLCertificate # Only create if SSLCertificateArn is provided
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificateArn
      SslPolicy: ELBSecurityPolicy-2016-08 # Choose an appropriate SSL policy
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ALBTargetGroup # Default to forwarding to the App server for API traffic

  # Update AppServerSecurityGroup to allow traffic from ALB
  AppServerSecurityGroupIngressFromALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref AppServerSecurityGroup
      IpProtocol: tcp
      FromPort: 5000 # ECS Task port
      ToPort: 5000
      SourceSecurityGroupId: !Ref ALBSecurityGroup # Allow from ALB's SG

Outputs:
  # CloudFront Distribution URL
  CloudFrontURL:
    Description: "CloudFront Distribution URL for the AI-SPM Platform"
    Value: !Sub "https://${CloudFrontDistribution.DomainName}"
    Export:
      Name: !Sub ${AWS::StackName}-CloudFrontURL

  # Application Load Balancer URL
  ALBEndpoint:
    Description: "Application Load Balancer endpoint for API access"
    Value: !Sub "http://${ApplicationLoadBalancer.DNSName}"
    Export:
      Name: !Sub ${AWS::StackName}-ALBEndpoint

  # ECR Repository URIs
  ECRRepositoryNodeJSURI:
    Description: "ECR Repository URI for Node.js API Gateway images"
    Value: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryNodeJS}"
    Export:
      Name: !Sub ${AWS::StackName}-ECRRepositoryNodeJS

  ECRRepositoryPythonURI:
    Condition: DeployMicroservices
    Description: "ECR Repository URI for Python Microservices images"
    Value: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryPython}"
    Export:
      Name: !Sub ${AWS::StackName}-ECRRepositoryPython

  # S3 Bucket for Frontend Assets
  S3FrontendBucketName:
    Description: "S3 Bucket name for frontend static assets"
    Value: !Ref S3FrontendBucket
    Export:
      Name: !Sub ${AWS::StackName}-S3FrontendBucket

  # Database Information
  DatabaseEndpoint:
    Description: "RDS PostgreSQL Database endpoint"
    Value: !GetAtt RDSPostgresInstance.Endpoint.Address
    Export:
      Name: !Sub ${AWS::StackName}-DatabaseEndpoint

  DatabasePort:
    Description: "RDS PostgreSQL Database port"
    Value: !GetAtt RDSPostgresInstance.Endpoint.Port
    Export:
      Name: !Sub ${AWS::StackName}-DatabasePort

  # ECS Cluster Information
  ECSClusterName:
    Description: "ECS Cluster name for the AI-SPM Platform"
    Value: !Ref ECSCluster
    Export:
      Name: !Sub ${AWS::StackName}-ECSCluster

  # API Gateway Service Information
  APIGatewayServiceName:
    Description: "ECS Service name for the Node.js API Gateway"
    Value: !Ref APIGatewayService
    Export:
      Name: !Sub ${AWS::StackName}-APIGatewayService

  # Microservices Service Information
  MicroservicesServiceName:
    Condition: DeployMicroservices
    Description: "ECS Service name for Python Microservices"
    Value: !Ref MicroservicesService
    Export:
      Name: !Sub ${AWS::StackName}-MicroservicesService

  # Service Discovery Information
  ServiceDiscoveryNamespace:
    Condition: DeployMicroservices
    Description: "Service Discovery namespace for microservices communication"
    Value: !Ref ServiceDiscoveryNamespace
    Export:
      Name: !Sub ${AWS::StackName}-ServiceDiscoveryNamespace

  # Architecture Information
  ArchitectureType:
    Description: "Architecture type deployed"
    Value: !Sub 
      - "${BaseArch} ${ServiceMeshSuffix}"
      - BaseArch: !If [DeployMicroservices, "Hybrid Microservices (Node.js + Python)", "API Gateway Only (Node.js)"]
        ServiceMeshSuffix: !If [EnableServiceMesh, "with Service Mesh Ready Infrastructure", ""]
    Export:
      Name: !Sub ${AWS::StackName}-ArchitectureType

  # Deployment Instructions
  DeploymentNotes:
    Description: "Important deployment information"
    Value: !Sub 
      - |
        Deployment completed successfully!
        
        Architecture: ${ArchType}
        Service Mesh: ${ServiceMeshStatus}
        
        Next Steps:
        1. Build and push Node.js API Gateway image to: ${ECRRepositoryNodeJS}
        ${MicroserviceInstructions}
        2. Upload frontend assets to S3 bucket: ${S3FrontendBucket}
        3. Access application via CloudFront: https://${CloudFrontDistribution.DomainName}
        
        ${ServiceMeshInstructions}
        
        For service mesh deployment:
        1. Deploy to EKS cluster: kubectl apply -f k8s/
        2. Install Istio: ./deploy/service-mesh-deployment.sh deploy
        3. Configure mTLS and authorization policies
        
        ${DiscoveryNotes}
      - ArchType: !If [DeployMicroservices, "Hybrid Microservices", "API Gateway Only"]
        ServiceMeshStatus: !If [EnableServiceMesh, "Ready for Istio deployment", "Standard deployment"]
        MicroserviceInstructions: !If [DeployMicroservices, !Sub "2. Build and push Python microservices images to: ${ECRRepositoryPython}", ""]
        ServiceMeshInstructions: !If [EnableServiceMesh, "Infrastructure configured for service mesh with mTLS support.", ""]
        DiscoveryNotes: !If [DeployMicroservices, "Microservices will be discoverable via internal DNS in the VPC.", ""]
    Export:
      Name: !Sub ${AWS::StackName}-DeploymentNotes
